# hsFillUp ---------------------------------------------------------------------

#' Fill-up with Missing Timestamps
#'
#' Based on the time series given in "tseries" a new time series is generated in
#' which timestamps that are lacking in tseries are included. Optionally missing
#' values are generated by interpolation between existing values.
#'
#' @param tseries data frame representing a time-series of values
#' @param tsField Name of timestamp column in tseries. Default: name of first
#'   available POSIXt-column
#' @param step_s Time step in seconds that shall lie between consecutive
#'   timestamps. Non-existing timestamps are generated.
#' @param forceStep If TRUE, only timestamps that are multiples of the time step
#'   given in step_s are put into the result data frame
#' @param limits data frame or matrix with exactly two columns containing first
#'   and last timestamp of intervals for which timestamps are to be generated.
#' @param interpol if TRUE, the returned data frame will for each value column
#'   contain a corresponding column containing interpolated values
#' @param includeOrig if TRUE and interpol = TRUE the original columns will
#'   remain in the output in addition to the columns containing all (original
#'   plus interpolated) values.
#' @param default value to be used if there are not enough (at least to) non-NA
#'   values to be used for interpolation. Default: NA
#' @param dbg If TRUE, debug messages are shown
#' @export
#' @return Returns a data.frame
#' @importFrom kwb.utils catIf posixColumnAtPosition selectColumns
hsFillUp <- function(
  tseries, tsField = names(tseries)[kwb.utils::posixColumnAtPosition(tseries)[1]], 
  step_s = 60, forceStep = TRUE, limits = NULL, interpol = TRUE, 
  includeOrig = TRUE, default = NA, dbg = FALSE
)
{
  # Stop if there are unexpected argument values
  .stopOnBadArguments(tseries, step_s, limits)
  
  # Select the vector of times
  timestamps <- kwb.utils::selectColumns(tseries, tsField)
  
  # Check if there are timestamps that are not at exact minutes (seconds = 0)
  .warnOnNoStepMultiples(timestamps = timestamps, step_s = step_s)
  
  # If no limits are given use the full time range of the timestamps in the
  # given data frame as "artificial" limits  
  if (is.null(limits)) {
    timeRange <- range(timestamps)
    limits <- data.frame(from = timeRange[1L], to = timeRange[2L])
  }
  
  # Initialise result (will become a data.frame)
  result <- NULL

  # Call fillup for each data block defined by the intervals given in limits 
  # (may be only one interval)
  blocks <- lapply(seq_len(nrow(limits)), function(i) {
    
    tbeg <- limits[[1L]][i]
    tend <- limits[[2L]][i]
    
    kwb.utils::catIf(dbg, sprintf("tbeg: %s, tend: %s\n", tbeg, tend))
    
    # Cut block of rows representing timestamps between tbeg and tend
    inRange <- kwb.utils::inRange(timestamps, tbeg, tend)
    
    # Skip empty areas
    if (!any(inRange)) {
      warning("No data available between the given limits: ",
              tbeg, " and ", tend, "!")
      return()
    }
      
    # Call fillup for the whole data block, not giving limits
    fillup(
      tseries = tseries[inRange, , drop = FALSE],
      tsField = tsField, 
      step_s = step_s, 
      forceStep = forceStep, 
      interpol = interpol, 
      includeOrig = includeOrig, 
      default = default, 
      dbg = dbg      
    )
  })
  
  do.call(rbind, blocks)
}

# .stopOnBadArguments ----------------------------------------------------------
.stopOnBadArguments <- function(tseries, step_s, limits)
{
  # The timeseries must be given as a data.frame
  if (!inherits(tseries, "data.frame")) {
    stop("In tseries, a data.frame must be given, containing timestamps",
         "in the first column.")
  }
  
  # The time-step must be given as a number
  if (!is.numeric(step_s)) {
    stop(sprintf("step_s must be numeric (is %s).", class(step_s)))
  }
  
  # If limits are given they must be of type matrix or data.frame
  if (!is.null(limits) && !(class(limits) %in% c("data.frame", "matrix"))) {
    stop(sprintf("limits must be data.frame or matrix (is %s).", class(limits)))
  }  
}

# .warnOnNoStepMultiples -------------------------------------------------------
.warnOnNoStepMultiples <- function(timestamps, step_s)
{
  isNoStepMultiple <- as.integer(timestamps) %% step_s != 0
  
  if (n <- sum(isNoStepMultiple)) {
    
    cat("There are", n, "timestamps",
        "(out of a total of", length(timestamps), ") that are not multiples",
        "of the timestep (", step_s, "seconds ):\n")
    
    print(utils::head(timestamps[isNoStepMultiple]))
  } 
}

# fillup -----------------------------------------------------------------------

#' Fill-up with Missing Timestamps
#'
#' Based on the time series given in "tseries" a new time series is generated in
#' which timestamps that are lacking in tseries are included. Optionally missing
#' values are generated by interpolation between existing values.
#'
#' @param tseries data frame representing a time-series of values
#' @param tsField Name of timestamp column in tseries. Default: name of first
#'   available POSIXt-column
#' @param step_s Time step in seconds that shall lie between consecutive
#'   timestamps. Non-existing timestamps are generated.
#' @param forceStep If TRUE, only timestamps that are multiples of the time step
#'   given in step_s are put into the result data frame
#' @param interpol if TRUE, the returned data frame will for each value column
#'   contain a corresponding column containing interpolated values
#' @param includeOrig if TRUE and interpol = TRUE the original columns will
#'   remain in the output in addition to the columns containing all (original
#'   plus interpolated) values.
#' @param default value to be used if there are not enough (at least to) non-NA
#'   values to be used for interpolation. Default: NA
#' @param dbg If TRUE, debug messages are shown
#'
#' @return Returns a data.frame
#' @export
#' @importFrom kwb.datetime roundTime
#' @importFrom kwb.utils selectColumns
fillup <- function(
  tseries, tsField, step_s, forceStep, interpol, includeOrig, default = NA, 
  dbg = FALSE   
)
{
  # Initialise result (will become a data.frame)
  result <- NULL
  
  # Fill-up between the first and the last timestamp of the given time series
  timeRange <- range(kwb.utils::selectColumns(tseries, tsField))
  
  # If needed, get lower minimum or greater maximum representing multiples
  # of the time step.
  tbeg <- kwb.datetime::roundTime(timeRange[1L], step_s, direction = 1L)
  tend <- kwb.datetime::roundTime(timeRange[2L], step_s, direction = 0L)
  
  # Generate the complete series of "regular" timestamps (multiples of 
  # time-step) between tbeg and tend
  
  # Handle the special case of only one value
  timestamps <- if (tbeg == tend) {
    tbeg
  } else {
    seq(tbeg, tend, by = step_s)    
  }
  
  tsBlock <- tseries
  
  if (dbg) {
    .showStartAndEndOfBlock(tsBlock, tbeg, tend, timestamps)
  }
  
  # Merge all timestamps with time series block by joining the regular 
  # timestamps (multiples of time-step) with the timestamps of the given 
  # timeseries block:
  # - If forceStep is TRUE we do a "left join", where the result only contains
  #   the "regular" timestamps (multiples of time-step).
  # - If forceStep is FALSE we do a "left or right join", where the result 
  #   contains both all "regular" timestamps (multiples of time-step) and all
  #   timestamps contained in the original timeseries.
  tsBlock <- merge(
    x = data.frame(timestamps = timestamps), 
    y = tsBlock, 
    by.x = "timestamps", 
    by.y = tsField, 
    all.x = TRUE, 
    all.y = !forceStep
  )
  
  # Interpolate values, if desired
  if (interpol) {
    tsBlock <- .interpolateAllColumns(
      tsBlock = tsBlock, 
      tseries = tseries, 
      tsField = tsField, 
      default = default, 
      dbg = dbg
    )
  }  
  
  # Set result data frame
  result <- tsBlock
  
  # Get column names without timestamp column
  dataColumnNames <- setdiff(colnames(tseries), tsField)
  
  # Set column names in result data.frame
  names(result) <- .newColumnNames(
    columnNames = dataColumnNames, 
    tsField = tsField, 
    interpol = interpol, 
    dbg = dbg
  )
  
  columns <- .reorderedAndSelectedColumns(
    numberOfColumns = ncol(result),
    numberOfDataColumns = length(dataColumnNames), 
    interpol = interpol, 
    includeOrig = includeOrig
  )
  
  result[, columns, drop = FALSE]
}

# .showStartAndEndOfBlock ------------------------------------------------------
.showStartAndEndOfBlock <- function(tsBlock, tbeg, tend, timestamps)
{
  cat(sprintf("Block of timeseries within %s and %s (full multiples of timestep)\n", tbeg, tend))
  print(utils::head(tsBlock))
  cat("...\n")
  print(utils::tail(tsBlock))
  cat(sprintf("Generated timestamps between %s and %s:\n", tbeg, tend))
  print(utils::head(timestamps))
  cat("...\n")
  print(utils::tail(timestamps))
  cat(sprintf("Available timestamps: %10d\n", nrow(tsBlock)))
  cat(sprintf("All timestamps:       %10d\n", length(timestamps)))      
}

# .interpolateAllColumns -------------------------------------------------------
#' @importFrom kwb.utils catIf selectColumns
.interpolateAllColumns <- function(
  tsBlock, tseries, tsField, default = NA, dbg = FALSE
)
{
  # Skip the timestamp field itself
  fields <- setdiff(colnames(tseries), tsField)
  
  # For each value field
  for (field in fields) {
    
    kwb.utils::catIf(dbg, sprintf("Interpolating field: %s\n", field))
    
    interpolated <- .getInterpolatedValues(
      timestamps = kwb.utils::selectColumns(tseries, tsField), 
      values = kwb.utils::selectColumns(tseries, field), 
      requiredTimestamps = tsBlock$timestamps, 
      default = default, 
      dbg = dbg
    )
    
    # Add column with interpolated values to the result data.frame
    tsBlock <- cbind(tsBlock, interpolated)
  }
  
  tsBlock
}

# .getInterpolatedValues -------------------------------------------------------
#' @keywords internal
#' @noRd
#' @noMd
#' @importFrom stats approx
#' @importFrom kwb.utils catIf
.getInterpolatedValues <- function(
  timestamps, values, requiredTimestamps, default = NA, dbg = FALSE
)
{
  # We need at least two non-NA values to interpolate
  if (sum(!is.na(values)) > 1L) {
    
    # Calculate interpolation for this field. approx returns a list with
    # components x and y of which we use the y component.
    interpolated <- stats::approx(
      timestamps, values, xout = requiredTimestamps
    )$y
    
  } else {
    
    # Determine a subsitute value. Either the value itself if there is only
    # one value or the given default value!
    substituteValue <- ifelse(length(values) == 1, values, default)
    
    kwb.utils::catIf(
      dbg, "Not at least two non-NA values available for interpolation!\n",
      "Using one value for all timestamps:", substituteValue, "\n"
    )
    
    interpolated <- rep(substituteValue, length(requiredTimestamps))
  }
  
  interpolated
}

# .newColumnNames --------------------------------------------------------------
#' @importFrom kwb.utils catIf
.newColumnNames <- function(columnNames, tsField, interpol, dbg = FALSE)
{
  if (interpol) {
    columnNames <- c(paste0(columnNames, "_orig"), columnNames)
  }
  
  columnNames <- c(tsField, columnNames)
  
  kwb.utils::catIf(
    dbg, sprintf("Column names: %s\n", paste(columnNames, collapse = ", "))
  )
  
  columnNames
}

# .reorderedAndSelectedColumns -------------------------------------------------
.reorderedAndSelectedColumns <- function(
  numberOfColumns, numberOfDataColumns, interpol, includeOrig
)
{
  # Start vector of column indices, starting with 1
  j <- 1L
  
  if (interpol) {
    j <- c(j, (numberOfDataColumns + 2L):numberOfColumns)
  }
  
  # If desired, include original columns  
  if (!interpol || includeOrig) {
    j <- c(j, 2:(numberOfDataColumns + 1L))
  }
  
  j
}

# demo_hsFillUp ----------------------------------------------------------------

#' Create Plot Demonstrating hsFillUp()
#' 
#' @return demo plot hsFillUp
#' @export
#' @importFrom stats rnorm
#' @importFrom graphics lines plot
#' @importFrom kwb.datetime hsToPosix
demo_hsFillUp <- function()
{
  message(
    "See the code creating the plot by typing 'demo_hsFillUp' and pressing ", 
    "Enter."
  )
  
  tstamps <- hsMkTimestamps("2010-03-27", to = "2010-03-30", step.s = 3600)
  
  df_1 <- data.frame(
    DateTimeUTC = tstamps,
    DataValue = stats::rnorm(n = length(tstamps))
  )
  
  limits <- data.frame(
    from = kwb.datetime::hsToPosix("2010-03-28"), 
    to = kwb.datetime::hsToPosix("2010-03-29")
  )
  
  df_2 <- hsFillUp(df_1, includeOrig = FALSE, limits = limits)
  
  graphics::plot(df_1, main = "hsFillUp() missing values within a range")
  
  graphics::lines(df_2, xlim = range(df_1$DateTimeUTC), type = "b", cex = 0.3)
}
